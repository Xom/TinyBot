<html><head><title>TinyBot record viewer</title><style>
html { background-color: #d4d0c8; font-size: 1vw; font-family: monospace }
table { display: inline-block; vertical-align: top }
.board td { width: 4vw; height: 4vw; font-size: 2.4vw; text-align: center; background-color: #b3d4fc }
#newTile { text-decoration: underline }
.board td.land { background-color: #c0ae70 }
.heat td { width: 0.5vw; height: 0.5vw }
table.heat { margin-bottom: 1vw }
button, label { margin-right: 0.5vw; font-size: 1vw }
</style></head><body>
<table id="myBoard" class="board"><tr><th>Game record not loaded</th></tr></table>
<div style="display:inline-block;vertical-align:top;padding:0.5vw;width:48vw">
  <button type="button" onclick="goBack()">Back</button>
  <button type="button" onclick="goForward()" autofocus>Forward</button>
  <button type="button" onclick="goJump(0)">0</button>
  <button type="button" onclick="goJump(10)">1</button>
  <button type="button" onclick="goJump(20)">2</button>
  <button type="button" onclick="goJump(29)">3</button>
  <form name="myRadios">
    <label style="margin-left:1vw">Mode:</label>
    <input type="radio" id="r_normal" name="radio" value="r_normal" checked>
    <label for="r_normal">Normal</label>
    <input type="radio" id="r_wwyd" name="radio" value="r_wwyd">
    <label for="r_wwyd">WWYD</label>
    <input type="radio" id="r_shuffle" name="radio" value="r_shuffle">
    <label for="r_shuffle">Shuffle only</label>
  </form>
  <div id="myPane" style="width:100%;margin-top:1vw"></div>
</div>
<script type="text/javascript">

const kBlank = 0;
const kForest = 1;
const kHouse = 2;
const kSand = 3;
const kWave = 4;
const kMountain = 5;
const kChurch = 6;
const kBoat = 7;
const kZoneZ = [
  [0, 1, 2, 3, 4, 5, 6, 7, 8],
  [9, 10, 11, 12, 13, 14, 15, 16, 17],
  [18, 19, 20, 21, 22, 23, 24, 25, 26],
  [27, 28, 29, 30, 31, 32, 33, 34, 35],
  [36, 37, 38, 39, 40, 41, 42, 43, 44],
  [45, 46, 47, 48, 49, 50, 51, 52, 53],
  [54, 55, 56, 57, 58, 59, 60, 61, 62],
  [63, 64, 65, 66, 67, 68, 69, 70, 71],
  [72, 73, 74, 75, 76, 77, 78, 79, 80],
  [0, 9, 18, 27, 36, 45, 54, 63, 72],
  [1, 10, 19, 28, 37, 46, 55, 64, 73],
  [2, 11, 20, 29, 38, 47, 56, 65, 74],
  [3, 12, 21, 30, 39, 48, 57, 66, 75],
  [4, 13, 22, 31, 40, 49, 58, 67, 76],
  [5, 14, 23, 32, 41, 50, 59, 68, 77],
  [6, 15, 24, 33, 42, 51, 60, 69, 78],
  [7, 16, 25, 34, 43, 52, 61, 70, 79],
  [8, 17, 26, 35, 44, 53, 62, 71, 80],
  [0, 1, 2, 9, 10, 11, 18, 19, 20],
  [3, 4, 5, 12, 13, 14, 21, 22, 23],
  [6, 7, 8, 15, 16, 17, 24, 25, 26],
  [27, 28, 29, 36, 37, 38, 45, 46, 47],
  [30, 31, 32, 39, 40, 41, 48, 49, 50],
  [33, 34, 35, 42, 43, 44, 51, 52, 53],
  [54, 55, 56, 63, 64, 65, 72, 73, 74],
  [57, 58, 59, 66, 67, 68, 75, 76, 77],
  [60, 61, 62, 69, 70, 71, 78, 79, 80],
];
const kTileChars = '.fhswMCB';
const kXChars = 'abcdefghi';
const kYChars = '987654321';
const kMovePass = 648;

const kDrawModeInitial = 0;
const kDrawModeUL = 1;
const kDrawModeUR = 2;
const kDrawModeLL = 3;
const kDrawModeLR = 4;
const kDrawModeW = 5;
const kDrawModeE = 6;
const kDrawModeN = 7;
const kDrawModeS = 8;
const kDrawModeWN = 9;
const kDrawModeWS = 10;
const kDrawModeEN = 11;
const kDrawModeES = 12;
const kDrawModeNW = 13;
const kDrawModeNE = 14;
const kDrawModeSW = 15;
const kDrawModeSE = 16;
const kPriorityDummy = 0.75;
const kDrawForbidden = 0;
const kDrawUnavailable = 0.25;
const kDrawFlag = 4;

const kScoreLabels = ['Penalties', 'Forests', 'Houses', 'Sand', 'Waves', 'Mountains', 'Churches', 'Boats', 'Total'];

class Board {
  constructor (clonee = null) {
    if (clonee) {
      this.priority = [...clonee.priority];
      this.land = [...clonee.land];
      this.tile = [...clonee.tile];
      this.deck = [...clonee.deck];
      this.zone = [...clonee.zone];
      this.offerTile = [...clonee.offerTile];
      this.offerZone = [...clonee.offerZone];
      this.ink = clonee.ink;
      this.placementsRemaining = clonee.placementsRemaining;
      this.placementsUntilDraw = clonee.placementsUntilDraw;
      this.drawingsCompleted = clonee.drawingsCompleted;
      this.drawMode = clonee.drawMode;
      this.score = [...clonee.score];
      this.indirectOverlap = clonee.indirectOverlap;
      this.isFinalScore = clonee.isFinalScore;
      this.isPlayerTurn = clonee.isPlayerTurn;
    } else {
      this.priority = [];
      this.land = [];
      this.tile = [];
      for (let z = 0; z < 81; z++) {
        this.priority.push(0);
        this.land.push(0);
        this.tile.push(0);
      }
      this.deck = [54, 13, 10, 9, 9, 5, 5, 3];
      this.zone = [];
      for (let i = 0; i < 27; i++) {
        this.zone.push(2);
      }
      this.offerTile = [0, 0];
      this.offerZone = [0, 0];
      this.ink = 0;
      this.placementsRemaining = 26;
      this.placementsUntilDraw = 9;
      this.drawingsCompleted = 0;
      this.drawMode = 0;
      this.score = [];
      for (let i = 0; i < 9; i++) {
        this.score.push(0);
      }
      this.indirectOverlap = false;
      this.isFinalScore = false;
      this.isPlayerTurn = false;
    }
  }

  offer (myOffer) {
    this.deck[0] -= 2;
    this.deck[myOffer.offerTile[0]]--;
    this.deck[myOffer.offerTile[1]]--;
    this.zone[myOffer.offerZone[0]]--;
    this.zone[myOffer.offerZone[1]]--;
    this.offerTile[0] = myOffer.offerTile[0];
    this.offerTile[1] = myOffer.offerTile[1];
    this.offerZone[0] = myOffer.offerZone[0];
    this.offerZone[1] = myOffer.offerZone[1];
    for (let i = 0; i < 2; i++) {
      for (const z of kZoneZ[this.offerZone[i]]) {
        if (this.tile[z] === kBlank) {
          const move = this.offerTile[i] * 81 + z;
          if (this.priority[move - 648] !== 1) {
            this.priority[move - 648] = 1;
          }
        }
      }
    }
    this.isPlayerTurn = true;
  }

  initDraw () {
    this.ink = 2;
    this.drawMode = kDrawModeInitial;
    switch (this.drawingsCompleted) {
      case 0:
        for (let z = 0; z < 81; z++) {
          this.priority[z] = kPriorityDummy;
        }
        break;
      case 1:
        this.initDrawLimitedIndirect();
        break;
      default:
        this.initThirdDraw();
        break;
    }
  }

  initDrawLimitedIndirect () {
    let maxPriority = 0;
    const best = [];
    for (let z = 0; z < 81; z++) {
      const x = z % 9;
      if (this.land[z] === 0) {
        const y = Math.floor(z / 9);
        if (this.canDirectWater(z, x, y)) {
          this.priority[z] = kPriorityDummy;
        } else {
          this.priority[z] = kDrawForbidden;
          if (kPriorityDummy > maxPriority) {
            maxPriority = kPriorityDummy;
            best.length = 0;
            best.push(z);
          } else if (kPriorityDummy === maxPriority) {
            best.push(z);
          }
        }
      } else {
        if (x === 0 || x === 8) {
          this.priority[z] = kDrawForbidden;
          this.initDrawForbiddingIndirect(z);
          return;
        }
        const y = Math.floor(z / 9);
        if (y === 0 || y === 8) {
          this.priority[z] = kDrawForbidden;
          this.initDrawForbiddingIndirect(z);
          return;
        }
        this.priority[z] = this.canDirectLand(z) ? kPriorityDummy : kDrawForbidden;
      }
    }
    if (this.enoughInkForSingleIndirect()) {
      for (const z of best) {
        this.priority[z] = 1;
      }
    }
  }

  initDrawSpecificIndirect (outside) {
    let maxPriority = 0;
    const best = [];
    for (let z = 0; z < 81; z++) {
      if (outside[z]) {
        this.priority[z] = kDrawForbidden;
        if (kPriorityDummy > maxPriority) {
          maxPriority = kPriorityDummy;
          best.length = 0;
          best.push(z);
        } else if (kPriorityDummy === maxPriority) {
          best.push(z);
        }
      }
    }
    for (const z of best) {
      this.priority[z] = 1;
    }
  }

  initDrawForbiddingIndirect (z) {
    for (z++; z < 81; z++) {
      const x = z % 9;
      if (this.land[z] === 0) {
        const y = Math.floor(z / 9);
        this.priority[z] = this.canDirectWater(z, x, y) ? kPriorityDummy : kDrawForbidden;
      } else {
        if (x === 0 || x === 8) {
          this.priority[z] = kDrawForbidden;
          continue;
        }
        const y = Math.floor(z / 9);
        if (y === 0 || y === 8) {
          this.priority[z] = kDrawForbidden;
          continue;
        }
        this.priority[z] = this.canDirectLand(z) ? kPriorityDummy : kDrawForbidden;
      }
    }
  }

  initThirdDraw () {
    // ink and draw mode already set
    const fill = [];

    let ink1 = 0;
    const outside1 = [];
    for (let z = 0; z < 81; z++) {
      outside1.push(false);
    }
    for (let z = 0; z < 8; z++) {
      if (this.land[z] === 1 || this.land[z + 73] === 1 || this.land[z * 9 + 8] === 1 || this.land[z * 9 + 9] === 1) {
        ink1 = -1;
        break;
      }
    }
    if (ink1 === 0) {
      for (const z of [0, 8, 72, 80]) {
        if (this.canDirectWaterSpecific2(1, z)) {
          outside1[z] = true;
          fill.push(z);
        } else {
          ink1 += 2;
        }
      }
      for (let a = 1; a <= 7; a++) {
        for (const z of [a, a + 72, a * 9, a * 9 + 8]) {
          if (this.canDirectWaterSpecific2(1, z)) {
            outside1[z] = true;
            fill.push(z);
          } else {
            ink1++;
          }
        }
      }
      while (fill.length !== 0) {
        const z = fill.pop();
        const x = z % 9;
        const y = Math.floor(z / 9);
        if (x !== 0 && !outside1[z - 1]) {
          if (this.canDirectWaterSpecific(1, z - 1, x - 1, y)) {
            outside1[z - 1] = true;
            fill.push(z - 1);
          } else {
            ink1++;
          }
        }
        if (x !== 8 && !outside1[z + 1]) {
          if (this.canDirectWaterSpecific(1, z + 1, x + 1, y)) {
            outside1[z + 1] = true;
            fill.push(z + 1);
          } else {
            ink1++;
          }
        }
        if (y !== 0 && !outside1[z - 9]) {
          if (this.canDirectWaterSpecific(1, z - 9, x, y - 1)) {
            outside1[z - 9] = true;
            fill.push(z - 9);
          } else {
            ink1++;
          }
        }
        if (y !== 8 && !outside1[z + 9]) {
          if (this.canDirectWaterSpecific(1, z + 9, x, y + 1)) {
            outside1[z + 9] = true;
            fill.push(z + 9);
          } else {
            ink1++;
          }
        }
      }
    }

    let ink2 = 0;
    const outside2 = [];
    for (let z = 0; z < 81; z++) {
      outside2.push(false);
    }
    for (let z = 0; z < 8; z++) {
      if (this.land[z] === 2 || this.land[z + 73] === 2 || this.land[z * 9 + 8] === 2 || this.land[z * 9 + 9] === 2) {
        ink2 = -1;
        break;
      }
    }
    if (ink2 === 0) {
      for (const z of [0, 8, 72, 80]) {
        if (this.canDirectWaterSpecific2(2, z)) {
          outside2[z] = true;
          fill.push(z);
        } else {
          ink2 += 2;
        }
      }
      for (let a = 1; a <= 7; a++) {
        for (const z of [a, a + 72, a * 9, a * 9 + 8]) {
          if (this.canDirectWaterSpecific2(2, z)) {
            outside2[z] = true;
            fill.push(z);
          } else {
            if (ink1 !== -1 && !outside1[z]) {
              this.indirectOverlap = true;
              this.initDrawLimitedIndirect();
              return;
            }
            ink2++;
          }
        }
      }
      while (fill.length !== 0) {
        const z = fill.pop();
        const x = z % 9;
        const y = Math.floor(z / 9);
        if (x !== 0 && !outside2[z - 1]) {
          if (this.canDirectWaterSpecific(2, z - 1, x - 1, y)) {
            outside2[z - 1] = true;
            fill.push(z - 1);
          } else {
            if (ink1 !== -1 && !outside1[z - 1]) {
              this.indirectOverlap = true;
              this.initDrawLimitedIndirect();
              return;
            }
            ink2++;
          }
        }
        if (x !== 8 && !outside2[z + 1]) {
          if (this.canDirectWaterSpecific(2, z + 1, x + 1, y)) {
            outside2[z + 1] = true;
            fill.push(z + 1);
          } else {
            if (ink1 !== -1 && !outside1[z + 1]) {
              this.indirectOverlap = true;
              this.initDrawLimitedIndirect();
              return;
            }
            ink2++;
          }
        }
        if (y !== 0 && !outside2[z - 9]) {
          if (this.canDirectWaterSpecific(2, z - 9, x, y - 1)) {
            outside2[z - 9] = true;
            fill.push(z - 9);
          } else {
            if (ink1 !== -1 && !outside1[z - 9]) {
              this.indirectOverlap = true;
              this.initDrawLimitedIndirect();
              return;
            }
            ink2++;
          }
        }
        if (y !== 8 && !outside2[z + 9]) {
          if (this.canDirectWaterSpecific(2, z + 9, x, y + 1)) {
            outside2[z + 9] = true;
            fill.push(z + 9);
          } else {
            if (ink1 !== -1 && !outside1[z + 9]) {
              this.indirectOverlap = true;
              this.initDrawLimitedIndirect();
              return;
            }
            ink2++;
          }
        }
      }
      if (ink2 !== 0) {
        switch (ink1) {
          case -1:
            if (ink2 <= 24) {
              for (let z = 0; z < 81; z++) {
                if (!outside2[z] && !this.canDirectWaterSpecific2(1, z)) {
                  this.indirectOverlap = true;
                  break;
                }
              }
              if (this.indirectOverlap) {
                this.initDrawForbiddingIndirect(-1);
              } else {
                this.initDrawSpecificIndirect(outside2);
              }
            } else {
              this.initDrawForbiddingIndirect(-1);
            }
            return;
          case 0:  // TODO implement indirect around lake
            if (ink2 <= 24) {
              this.initDrawSpecificIndirect(outside2);
            } else {
              this.initDrawForbiddingIndirect(-1);
            }
            return;
          // case 0:
            // break;
          default:
            if (ink1 <= 24) {
              if (ink2 <= 24) {
                let maxPriority1 = 0;
                let maxPriority2 = 0;
                const best1 = [];
                const best2 = [];
                for (let z = 0; z < 81; z++) {
                  if (outside1[z]) {
                    if (outside2[z]) {
                      this.priority[z] = kPriorityDummy;
                    } else {
                      this.priority[z] = kDrawForbidden;
                      if (kPriorityDummy > maxPriority2) {
                        maxPriority2 = kPriorityDummy;
                        best2.length = 0;
                        best2.push(z);
                      } else if (kPriorityDummy === maxPriority2) {
                        best2.push(z);
                      }
                    }
                  } else {
                    this.priority[z] = kDrawForbidden;
                    if (kPriorityDummy > maxPriority1) {
                      maxPriority1 = kPriorityDummy;
                      best1.length = 0;
                      best1.push(z);
                    } else if (kPriorityDummy === maxPriority1) {
                      best1.push(z);
                    }
                  }
                }
                for (const z of best1) {
                  this.priority[z] = 1;
                }
                for (const z of best2) {
                  this.priority[z] = 1;
                }
              } else {
                this.initDrawSpecificIndirect(outside1);
              }
            } else {
              if (ink2 <= 24) {
                this.initDrawSpecificIndirect(outside2);
              } else {
                this.initDrawForbiddingIndirect(-1);
              }
            }
            return;
        }
      } else {
        // TODO implement indirect around lake
        if (ink1 !== -1 && ink1 <= 24) {
          this.initDrawSpecificIndirect(outside1);
        } else {
          this.initDrawForbiddingIndirect(-1);
        }
      }
    } else {
      // ink2 === -1
      switch (ink1) {
        case -1:
        case 0:  // TODO implement indirect around lake
          this.initDrawForbiddingIndirect(-1);
          return;
        // case 0:
          // break;
        default:
          if (ink1 <= 24) {
            for (let z = 0; z < 81; z++) {
              if (!outside1[z] && !this.canDirectWaterSpecific2(2, z)) {
                this.indirectOverlap = true;
                break;
              }
            }
            if (this.indirectOverlap) {
              this.initDrawForbiddingIndirect(-1);
            } else {
              this.initDrawSpecificIndirect(outside1);
            }
          } else {
            this.initDrawForbiddingIndirect(-1);
          }
          return;
      }
    }

    // TODO implement indirect around lake
    // inkN interpretation: if inkN === 0, n is a lake, otherwise it's an island; if 0 < inkN <= 24, indirect is possible; note 1 and 2 can't both be lake
    // without having implemented indirect around lake, currently treating 0 as indirect impossible
  }

  canDirectWater (z, x, y) {
    return (y === 0 || (x === 0 || this.land[z - 10] === 0) && this.land[z - 9] === 0 && (x === 8 || this.land[z - 8] === 0)) && (x === 0 || this.land[z - 1] === 0) && (x === 8 || this.land[z + 1] === 0) && (y === 8 || (x === 0 || this.land[z + 8] === 0) && this.land[z + 9] === 0 && (x === 8 || this.land[z + 10] === 0));
  }

  canDirectLand (z) {
    return this.land[z] === this.land[z - 10] && this.land[z] === this.land[z - 9] && this.land[z] === this.land[z - 8] && this.land[z] === this.land[z - 1] && this.land[z] === this.land[z + 1] && this.land[z] === this.land[z + 8] && this.land[z] === this.land[z + 9] && this.land[z] === this.land[z + 10];
  }

  canDirectWaterSpecific (l, z, x, y) {
    return (y === 0 || (x === 0 || this.land[z - 10] !== l) && this.land[z - 9] !== l && (x === 8 || this.land[z - 8] !== l)) && (x === 0 || this.land[z - 1] !== l) && (x === 8 || this.land[z + 1] !== l) && (y === 8 || (x === 0 || this.land[z + 8] !== l) && this.land[z + 9] !== l && (x === 8 || this.land[z + 10] !== l));
  }

  canDirectWaterSpecific2 (l, z) {
    return this.canDirectWaterSpecific(l, z, z % 9, Math.floor(z / 9));
  }

  enoughInkForSingleIndirect () {
    let indirectInk = 0;
    const outside = [];
    for (let z = 0; z < 81; z++) {
      outside.push(false);
    }
    const fill = [];
    for (const z of [0, 8, 72, 80]) {
      if (this.priority[z] === kDrawForbidden) {
        indirectInk += 2;
      } else {
        outside[z] = true;
        fill.push(z);
      }
    }
    for (let a = 1; a <= 7; a++) {
      for (const z of [a, a + 72, a * 9, a * 9 + 8]) {
        if (this.priority[z] === kDrawForbidden) {
          indirectInk++;
        } else {
          outside[z] = true;
          fill.push(z);
        }
      }
    }
    while (fill.length !== 0) {
      const z = fill.pop();
      const x = z % 9;
      if (x !== 0 && !outside[z - 1]) {
        if (this.priority[z - 1] === kDrawForbidden) {
          indirectInk++;
          if (indirectInk === 25) {
            return false;
          }
        } else {
          outside[z - 1] = true;
          fill.push(z - 1);
        }
      }
      if (x !== 8 && !outside[z + 1]) {
        if (this.priority[z + 1] === kDrawForbidden) {
          indirectInk++;
          if (indirectInk === 25) {
            return false;
          }
        } else {
          outside[z + 1] = true;
          fill.push(z + 1);
        }
      }
      const y = Math.floor(z / 9);
      if (y !== 0 && !outside[z - 9]) {
        if (this.priority[z - 9] === kDrawForbidden) {
          indirectInk++;
          if (indirectInk === 25) {
            return false;
          }
        } else {
          outside[z - 9] = true;
          fill.push(z - 9);
        }
      }
      if (y !== 8 && !outside[z + 9]) {
        if (this.priority[z + 9] === kDrawForbidden) {
          indirectInk++;
          if (indirectInk === 25) {
            return false;
          }
        } else {
          outside[z + 9] = true;
          fill.push(z + 9);
        }
      }
    }
    return true;
  }

  doDraw (z) {
    if (z === kMovePass) {
      this.isPlayerTurn = false;
      this.drawingsCompleted++;
      for (let zz = 0; zz < 81; zz++) {
        if (this.land[zz] === kDrawFlag) {
          this.land[zz] = this.drawingsCompleted;
        } else if (this.land[zz] > kDrawFlag) {
          this.land[zz] = 0;
        }
      }
      if (this.drawingsCompleted === 3) {
        return;
      }
      this.lastInk = this.ink;
      this.ink = 0;
      this.placementsUntilDraw = this.drawingsCompleted === 2 ? 8 : 9;
      for (let zz = 0; zz < 81; zz++) {
        this.priority[zz] = kDrawForbidden;
      }
      return;
    }

    const x = z % 9;
    const y = Math.floor(z / 9);
    if (this.ink === 2) {
      // TODO implement indirect around lake
      if (this.land[z] === 0 && this.priority[z] === 1) {
        this.doDrawIndirect(this.drawingsCompleted !== 2 || this.indirectOverlap ? 0 : this.findIndirect(z, x, y), x, y);
        return;
      } else {
        this.ink = 4;
      }
    } else {
      this.ink += (x === 0 || this.land[z - 1] < kDrawFlag ? 1 : -1) + (x === 8 || this.land[z + 1] < kDrawFlag ? 1 : -1) + (y === 0 || this.land[z - 9] < kDrawFlag ? 1 : -1) + (y === 8 || this.land[z + 9] < kDrawFlag ? 1 : -1);
    }
    this.land[z] += kDrawFlag;
    const priorityPlusEpsilon = this.priority[z] + 0.00390625;  // 1/256 is a nice round number smaller than the smallest priority increment of 1/164
    this.priority[z] = kDrawForbidden;
    this.updateDrawMode(x, y);
    if (this.ink === 24) {
      for (let zz = 0; zz < 81; zz++) {
        const p = this.priority[zz];
        if (p === kDrawUnavailable) {
          if (this.isDrawableWithoutInk(this.land[z], zz)) {
            this.priority[zz] = kPriorityDummy;
          }
        } else if (p > kDrawUnavailable) {
          if (p < priorityPlusEpsilon) {
            this.priority[zz] = this.isDrawableWithoutInk(this.land[z], zz) ? kPriorityDummy : kDrawUnavailable;
          } else {
            this.priority[zz] = kDrawForbidden;
          }
        }
      }
    } else {
      for (let zz = 0; zz < 81; zz++) {
        const p = this.priority[zz];
        if (p === kDrawUnavailable) {
          if (this.isDrawable(this.land[z], zz)) {
            this.priority[zz] = kPriorityDummy;
          }
        } else if (p > kDrawUnavailable) {
          if (p < priorityPlusEpsilon) {
            this.priority[zz] = this.isDrawable(this.land[z], zz) ? kPriorityDummy : kDrawUnavailable;
          } else {
            this.priority[zz] = kDrawForbidden;
          }
        }
      }
    }
  }

  doDrawIndirect (l, xx, yy) {
    // TODO implement indirect around lake
    this.ink = 0;
    const outside = [];
    for (let z = 0; z < 81; z++) {
      outside.push(false);
    }
    const fill = [];
    for (const z of [0, 8, 72, 80]) {
      if ((this.priority[z] === kDrawForbidden || this.priority[z] === 1) && (l === 0 || !this.canDirectWaterSpecific2(l, z))) {
        this.ink += 2;
      } else {
        outside[z] = true;
        fill.push(z);
      }
    }
    for (let a = 1; a <= 7; a++) {
      for (const z of [a, a + 72, a * 9, a * 9 + 8]) {
        if (( this.priority[z] === kDrawForbidden || this.priority[z] === 1) && (l === 0 || !this.canDirectWaterSpecific2(l, z))) {
          this.ink++;
        } else {
          outside[z] = true;
          fill.push(z);
        }
      }
    }
    while (fill.length !== 0) {
      const z = fill.pop();
      const x = z % 9;
      const y = Math.floor(z / 9);
      if (x !== 0 && !outside[z - 1]) {
        if ((this.priority[z - 1] === kDrawForbidden || this.priority[z - 1] === 1) && (l === 0 || !this.canDirectWaterSpecific(l, z - 1, x - 1, y))) {
          this.ink++;
        } else {
          outside[z - 1] = true;
          fill.push(z - 1);
        }
      }
      if (x !== 8 && !outside[z + 1]) {
        if ((this.priority[z + 1] === kDrawForbidden || this.priority[z + 1] === 1) && (l === 0 || !this.canDirectWaterSpecific(l, z + 1, x + 1, y))) {
          this.ink++;
        } else {
          outside[z + 1] = true;
          fill.push(z + 1);
        }
      }
      if (y !== 0 && !outside[z - 9]) {
        if ((this.priority[z - 9] === kDrawForbidden || this.priority[z - 9] === 1) && (l === 0 || !this.canDirectWaterSpecific(l, z - 9, x, y - 1))) {
          this.ink++;
        } else {
          outside[z - 9] = true;
          fill.push(z - 9);
        }
      }
      if (y !== 8 && !outside[z + 9]) {
        if ((this.priority[z + 9] === kDrawForbidden || this.priority[z + 9] === 1) && (l === 0 || !this.canDirectWaterSpecific(l, z + 9, x, y + 1))) {
          this.ink++;
        } else {
          outside[z + 9] = true;
          fill.push(z + 9);
        }
      }
    }

    for (let z = 0; z < 81; z++) {
      if (!outside[z]) {
        this.land[z] += kDrawFlag;
        this.priority[z]= kDrawForbidden;
      }
    }
    this.updateDrawMode(xx, yy);
    if (this.ink === 24) {
      for (let z = 0; z < 81; z++) {
        if (outside[z]) {
          this.priority[z] = this.isDrawableWithoutInk(kDrawFlag, z) ? kPriorityDummy : kDrawUnavailable;
        }
      }
    } else {
      for (let z = 0; z < 81; z++) {
        if (outside[z]) {
          this.priority[z] = this.isDrawable(kDrawFlag, z) ? kPriorityDummy : kDrawUnavailable;
        }
      }
    }
  }

  updateDrawMode (x, y) {
    switch (this.drawMode) {
      case kDrawModeInitial:
        if (x < 4) {
          if (y < 4) {
            const ax = Math.abs(x - 4);
            const ay = Math.abs(y - 4);
            if (ax < ay) {
              this.drawMode = kDrawModeNW;
            } else if (ax === ay) {
              this.drawMode = kDrawModeUL;
            } else {
              this.drawMode = kDrawModeWN;
            }
          } else if (y === 4) {
            this.drawMode = kDrawModeW;
          } else {
            const ax = Math.abs(x - 4);
            const ay = Math.abs(y - 4);
            if (ax < ay) {
              this.drawMode = kDrawModeSW;
            } else if (ax === ay) {
              this.drawMode = kDrawModeLL;
            } else {
              this.drawMode = kDrawModeWS;
            }
          }
        } else if (x === 4) {
          if (y < 4) {
            this.drawMode = kDrawModeN;
          } else if (y !== 4) {
            this.drawMode = kDrawModeS;
          }
        } else {
          if (y < 4) {
            const ax = Math.abs(x - 4);
            const ay = Math.abs(y - 4);
            if (ax < ay) {
              this.drawMode = kDrawModeNE;
            } else if (ax === ay) {
              this.drawMode = kDrawModeUR;
            } else {
              this.drawMode = kDrawModeEN;
            }
          } else if (y === 4) {
            this.drawMode = kDrawModeE;
          } else {
            const ax = Math.abs(x - 4);
            const ay = Math.abs(y - 4);
            if (ax < ay) {
              this.drawMode = kDrawModeSE;
            } else if (ax === ay) {
              this.drawMode = kDrawModeLR;
            } else {
              this.drawMode = kDrawModeES;
            }
          }
        }
        break;
      case kDrawModeUL:
        if (x < y) {
          this.drawMode = kDrawModeWN;
        } else if (x !== y) {
          this.drawMode = kDrawModeNW;
        }
        break;
      case kDrawModeUR:
        if (8 - x < y) {
          this.drawMode = kDrawModeEN;
        } else if (8 - x !== y) {
          this.drawMode = kDrawModeNE;
        }
        break;
      case kDrawModeLL:
        if (x < 8 - y) {
          this.drawMode = kDrawModeWS;
        } else if (x !== 8 - y) {
          this.drawMode = kDrawModeSW;
        }
        break;
      case kDrawModeLR:
        if (x < y) {
          this.drawMode = kDrawModeSE;
        } else if (x !== y) {
          this.drawMode = kDrawModeES;
        }
        break;
      case kDrawModeW:
        if (y < 4) {
          this.drawMode = kDrawModeWN;
        } else if (y !== 4) {
          this.drawMode = kDrawModeWS;
        }
        break;
      case kDrawModeE:
        if (y < 4) {
          this.drawMode = kDrawModeEN;
        } else if (y !== 4) {
          this.drawMode = kDrawModeES;
        }
        break;
      case kDrawModeN:
        if (x < 4) {
          this.drawMode = kDrawModeNW;
        } else if (x !== 4) {
          this.drawMode = kDrawModeNE;
        }
        break;
      case kDrawModeS:
        if (x < 4) {
          this.drawMode = kDrawModeSW;
        } else if (x !== 4) {
          this.drawMode = kDrawModeSE;
        }
        break;
      default:
        break;
    }
  }

  isDrawable (drawn, z) {
    const x = z % 9;
    const y = Math.floor(z / 9);
    let foundDrawn = false;
    let mask = 0;
    if (y !== 0) {
      if (this.land[z - 9] === drawn) {
        foundDrawn = true;
      }
      if (x !== 0 && this.isLand(this.land[z - 10])) {
        mask += 1;
      }
      if (this.isLand(this.land[z - 9])) {
        mask += 2;
      }
      if (x !== 8 && this.isLand(this.land[z - 8])) {
        mask += 4;
      }
    }
    if (x !== 8) {
      if (this.land[z + 1] === drawn) {
        foundDrawn = true;
      }
      if (this.isLand(this.land[z + 1])) {
        mask += 8;
      }
    }
    if (y !== 8) {
      if (this.land[z + 9] === drawn) {
        foundDrawn = true;
      }
      if (x !== 8 && this.isLand(this.land[z + 10])) {
        mask += 16;
      }
      if (this.isLand(this.land[z + 9])) {
        mask += 32;
      }
      if (x !== 0 && this.isLand(this.land[z + 8])) {
        mask += 64;
      }
    }
    if (x !== 0) {
      if (this.land[z - 1] === drawn) {
        foundDrawn = true;
      }
      if (this.isLand(this.land[z - 1])) {
        mask += 128;
      }
    }
    return foundDrawn && this.isCoast(mask);
  }

  isDrawableWithoutInk (drawn, z) {
    const x = z % 9;
    const y = Math.floor(z / 9);
    let foundDrawn = 0;
    let mask = 0;
    if (y !== 0) {
      if (this.land[z - 9] === drawn) {
        foundDrawn++;
      }
      if (x !== 0 && this.isLand(this.land[z - 10])) {
        mask += 1;
      }
      if (this.isLand(this.land[z - 9])) {
        mask += 2;
      }
      if (x !== 8 && this.isLand(this.land[z - 8])) {
        mask += 4;
      }
    }
    if (x !== 8) {
      if (this.land[z + 1] === drawn) {
        foundDrawn++;
      }
      if (this.isLand(this.land[z + 1])) {
        mask += 8;
      }
    }
    if (y !== 8) {
      if (this.land[z + 9] === drawn) {
        foundDrawn++;
      }
      if (x !== 8 && this.isLand(this.land[z + 10])) {
        mask += 16;
      }
      if (this.isLand(this.land[z + 9])) {
        mask += 32;
      }
      if (x !== 0 && this.isLand(this.land[z + 8])) {
        mask += 64;
      }
    }
    if (x !== 0) {
      if (this.land[z - 1] === drawn) {
        foundDrawn++;
      }
      if (this.isLand(this.land[z - 1])) {
        mask += 128;
      }
    }
    return foundDrawn >= 2 && this.isCoast(mask);
  }

  findIndirect (z, x, y) {
    if (y !== 8) {
      if (x !== 0 && this.land[z + 8] !== 0) {
        return this.land[z + 8];
      }
      if (x !== 8 && this.land[z + 10] !== 0) {
        return this.land[z + 10];
      }
    }
    if (y !== 0 && x !== 8 && this.land[z - 8] !== 0) {
      return this.land[z - 8];
    }
    return this.land[z - 10];
  }

  doPlace (z, t) {
    this.tile[z] = t;
    this.placementsRemaining--;
    this.placementsUntilDraw--;

    if (this.placementsRemaining === 0) {
      this.initDraw();
    } else {
      this.isPlayerTurn = false;  // time for offer
    }
  }

  isLand (l) {
    return l !== 0 && l <= kDrawFlag;
  }

  isCoast (mask) {
    switch (mask) {
      case 2:
      case 3:
      case 6:
      case 7:
      case 8:
      case 12:
      case 14:
      case 15:
      case 24:
      case 28:
      case 30:
      case 31:
      case 32:
      case 48:
      case 56:
      case 60:
      case 62:
      case 63:
      case 96:
      case 112:
      case 120:
      case 124:
      case 126:
      case 127:
      case 128:
      case 129:
      case 131:
      case 135:
      case 143:
      case 159:
      case 192:
      case 193:
      case 195:
      case 199:
      case 207:
      case 223:
      case 224:
      case 225:
      case 227:
      case 231:
      case 240:
      case 241:
      case 243:
      case 247:
      case 248:
      case 249:
      case 252:
      case 253:
        return true;
      default:
        return false;
    }
  }

  parseX (charCode) {
    return charCode - 97; // c - 'a'
  }

  parseY (charCode) {
    return 57 - charCode; // '9' - c
  }

  parseTile (c) {
    switch (c) {
      case 'f':
        return 1;
      case 'h':
        return 2;
      case 's':
        return 3;
      case 'w':
        return 4;
      case 'M':
        return 5;
      case 'C':
        return 6;
      case 'B':
        return 7;
      default:
        return 0;
    }
  }

  parseZone (c) {
    switch (c) {
      case '9':
        return 0;
      case '8':
        return 1;
      case '7':
        return 2;
      case '6':
        return 3;
      case '5':
        return 4;
      case '4':
        return 5;
      case '3':
        return 6;
      case '2':
        return 7;
      case '1':
        return 8;
      case 'a':
        return 9;
      case 'b':
        return 10;
      case 'c':
        return 11;
      case 'd':
        return 12;
      case 'e':
        return 13;
      case 'f':
        return 14;
      case 'g':
        return 15;
      case 'h':
        return 16;
      case 'i':
        return 17;
      case 'Q':
        return 18;
      case 'W':
        return 19;
      case 'E':
        return 20;
      case 'A':
        return 21;
      case 'S':
        return 22;
      case 'D':
        return 23;
      case 'Z':
        return 24;
      case 'X':
        return 25;
      default:
        return 26;
    }
  }

  parseOffer (token) {
    return {
      offerTile: [this.parseTile(token[0]), this.parseTile(token[2])],
      offerZone: [this.parseZone(token[1]), this.parseZone(token[3])],
    };
  }

  parseDistribution (token, cursor) {
    const moves = [];
    const priors = [];
    let sumP = 0;
    let n = 0;
    let more = true;
    do {
      cursor++;
      switch (token[cursor]) {
        case ':':
          moves.push(n);
          n = 0;
          break;
        case ',':
          sumP += n;
          priors.push(n);
          n = 0;
          break;
        case '0':
          n *= 10;
          break;
        case '1':
          n = n * 10 + 1;
          break;
        case '2':
          n = n * 10 + 2;
          break;
        case '3':
          n = n * 10 + 3;
          break;
        case '4':
          n = n * 10 + 4;
          break;
        case '5':
          n = n * 10 + 5;
          break;
        case '6':
          n = n * 10 + 6;
          break;
        case '7':
          n = n * 10 + 7;
          break;
        case '8':
          n = n * 10 + 8;
          break;
        case '9':
          n = n * 10 + 9;
          break;
        default:
          more = false;
          break;
      }
    } while (more);
    cursor++;

    n = moves.length;
    const multiplicand = 1 / sumP;
    for (let i = 0; i < n; i++) {
      // let m = moves[i];
      // if (m !== kMovePass) {
        // const x = m % 9;
        // const y = Math.floor((m % 81) / 9);
        // const t = Math.floor(m / 81);
        // m = t * 81 + y * 9 + x;
      // }
      priors[i] *= multiplicand;
    }
    return { cursor, moves, priors };
  }
}

function heatGrid (weights, denom) {
  let html = '<table class="heat">';
  for (let z = 0; z < 81; z++) {
    const x = z % 9;
    // const y = Math.floor(z / 9);
    if (x === 0) {
      html += '<tr>';
    }
    let rb = Math.floor(255 * (1 - (weights[z] / denom))).toString(16);
    while (rb.length < 2) {
      rb = '0' + rb;
    }
    let g = Math.floor(127 * (1 - (weights[z] / denom)) + 128).toString(16);
    while (g.length < 2) {
      g = '0' + g;
    }
    html += `<td style="background-color:#${rb}${g}${rb}"></td>`;
    if (x === 8) {
      html += '</tr>';
    }
  }
  html += '</table>';
  return html;
}

function showBoard () {
  if (radioState !== 'r_wwyd' || qPos === 0) {
    wwyd = false;
  }
  const board = qBoards[qPos];
  let html = '';
  if (radioState !== 'r_shuffle') {
    for (let z = 0; z < 81; z++) {
      const x = z % 9;
      if (radioState === 'r_wwyd' && (!wwyd) && (qPos === 10 || qPos === 20 || qPos === 29)) {
        html += `<td${qBoards[qPos - 1].land[z] === 0 ? '' : ' class="land"'}>${board.tile[z] === kBlank ? '' : kTileChars[board.tile[z]]}</td>`;
      } else if (radioState === 'r_wwyd' && (!wwyd) && qBoards[qPos - 1].tile[z] !== board.tile[z]) {
        html += `<td${board.land[z] === 0 ? '' : ' class="land"'}></td>`;
      } else {
        html += `<td${qPos !== 0 && qBoards[qPos - 1].tile[z] !== board.tile[z] ? ' id="newTile"' : ''}${board.land[z] === 0 ? '' : ' class="land"'}>${board.tile[z] === kBlank ? '' : kTileChars[board.tile[z]]}</td>`;
      }
      if (x === 8) {
        html += '</tr>';
      }
    }
  }
  document.getElementById('myBoard').innerHTML = html;
  html = '<div style="float:right">';
  const grids = [[], [], [], []];
  for (let i = 0; i < 4; i++) {
    for (let z = 0; z < 81; z++) {
      grids[i].push(0);
    }
  }
  for (let zone = 0; zone < 9; zone++) {
    for (const z of kZoneZ[zone]) {
      grids[0][z] += board.zone[zone];
      grids[3][z] += board.zone[zone];
    }
  }
  for (let zone = 9; zone < 18; zone++) {
    for (const z of kZoneZ[zone]) {
      grids[1][z] += board.zone[zone];
      grids[3][z] += board.zone[zone];
    }
  }
  for (let zone = 18; zone < 27; zone++) {
    for (const z of kZoneZ[zone]) {
      grids[2][z] += board.zone[zone];
      grids[3][z] += board.zone[zone];
    }
  }
  html += heatGrid(grids[3], 6);
  html += '<br>';
  for (let i = 0; i < 3; i++) {
    html += heatGrid(grids[i], 6);
    html += '<br>';
  }
  html += '</div>Remaining:';
  for (let t = 1; t <= 2; t++) {
    for (let i = 0; i < board.deck[t]; i++) {
      html += ' ';
      html += kTileChars[t];
    }
  }
  html += '<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';
  for (let t = 3; t <= 4; t++) {
    for (let i = 0; i < board.deck[t]; i++) {
      html += ' ';
      html += kTileChars[t];
    }
  }
  html += '<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';
  for (let t = 5; t <= 8; t++) {
    for (let i = 0; i < board.deck[t]; i++) {
      html += ' ';
      html += kTileChars[t];
    }
  }
  html += '<br><br>';
  let grid = [];
  if (qPos === 10 || qPos === 20 || qPos === 29) {
    if (radioState === 'r_shuffle' || (radioState === 'r_wwyd' && (!wwyd))) {
      html += 'Draw.';
    } else {
      for (let z = 0; z < 81; z++) {
        grid.push(qBoards[qPos - 1].land[z] === board.land[z] ? 0 : 1);
      }
      html += heatGrid(grid, 1);
      html += `<br><span style="font-size:smaller">${qPos === 29 ? board.ink : board.lastInk} ink used.</span>`;
      if (qPos === 29) {
        html += '<br>';
        for (let t = 0; t <= 8; t++) {
          let ss = [kScoreLabels[t] + ':', '' + qScore[t]];
          if (t === 0) {
            ss[1] = `(${ss[1]}`;
          }
          const spaces = 15 - ss[0].length - ss[1].length;
          html += '<br>';
          if (t === 8) {
            html += '<br>';
          }
          html += ss[0];
          for (let i = 0; i < spaces; i++) {
            html += '&nbsp;';
          }
          html += ss[1];
          if (t === 0) {
            html += ')';
          }
        }
        if (qScore[9]) {
          html += `<br><br><span style="font-size:smaller">Initial ${qScore[9]} move(s) were random.</span>`;
        }
      }
    }
  } else if (qPos !== 0) {
    const offer = board.parseOffer(qTokens[(qPos - 1) * 2 - Math.floor(qPos / 10)]);
    html += '<span style="font-size:4vw;margin-right:5vw">&nbsp;';
    html += kTileChars[offer.offerTile[0]];
    html += ' ';
    for (let z = 0; z < 81; z++) {
      grid.push(0);
    }
    for (const z of kZoneZ[offer.offerZone[0]]) {
      grid[z] = 1;
    }
    html += heatGrid(grid, 1);
    html += '</span> <span style="font-size:4vw">';
    html += kTileChars[offer.offerTile[1]];
    html += ' ';
    for (const z of kZoneZ[offer.offerZone[0]]) {
      grid[z] = 0;
    }
    for (const z of kZoneZ[offer.offerZone[1]]) {
      grid[z] = 1;
    }
    html += heatGrid(grid, 1);
    html += '</span>';

    const token = qTokens[(qPos - 1) * 2 - Math.floor(qPos / 10) + 1];
    if (token[0] === '{' && radioState !== 'r_shuffle' && (radioState !== 'r_wwyd' || wwyd)) {
      html += '<div style="font-size:smaller"><br>Consideration:<br>';
      const distribution = board.parseDistribution(token, 0);
      const n = distribution.moves.length;
      for (let i = 0; i < n; i++) {
        const m = distribution.moves[i];
        const x = m % 9;
        const y = Math.floor((m % 81) / 9);
        const t = Math.floor(m / 81);
        html += `<br>${kTileChars[t]}${kXChars[x]}${kYChars[y]} ${distribution.priors[i]}`;
      }
      html += '</div>';
    } else if (qScore[9] && qPos <= qScore[9] && radioState !== 'r_shuffle' && (radioState !== 'r_wwyd' || wwyd)) {
      html += '<div style="font-size:smaller"><br>Random move.</div>';
    }
  }
  document.getElementById('myPane').innerHTML = html;
}

function goBack () {
  if (wwyd) {
    wwyd = false;
    showBoard();
    return;
  }
  if (qPos > 0) {
    qPos--;
    if (radioState === 'r_wwyd') {
      wwyd = true;
    }
    showBoard();
  }
}

function goForward () {
  if (qPos < qBoards.length - 1 || (radioState === 'r_wwyd' && (!wwyd))) {
    if (radioState === 'r_wwyd' && !(wwyd || qPos === 0)) {
      wwyd = true;
    } else {
      wwyd = false;
      qPos++;
    }
    showBoard();
  }
}

function goJump (pos) {
  if (pos !== qPos) {
    qPos = pos;
    showBoard();
  }
}

const qTokens = decodeURIComponent(location.search).split(/[+ ]/);
if (qTokens[0][0] === '?') {
  qTokens[0] = qTokens[0].slice(1);
}
let qLast = qTokens.pop();
while (qLast.trim() === '') {
  qLast = qTokens.pop();
}
if (qLast[0] === '#') {
  document.title = qLast.slice(1).trim() + ' - TinyBot record viewer';
  qLast = qTokens.pop();
} else if (location.hash[0] === '#') {
  document.title = location.hash.slice(1).trim() + ' - TinyBot record viewer';
}
const qScore = [];
while (!isNaN(qLast)) {
  qScore.unshift(parseInt(qLast, 10));
  qLast = qTokens.pop();
}
qTokens.push(qLast);
const qBoards = [new Board()];
for (let i = 0; i < 55; i++) {
  let token = qTokens[i];
  const board = new Board(qBoards[qBoards.length - 1]);
  qBoards.push(board);
  if (i === 18 || i === 37 || i === 54) {
    (function(){
      let cursor = 0;
      while (true) {
        if (token[cursor] === '{') {
          cursor = board.parseDistribution(token, cursor).cursor;
        }
        if (cursor === token.length) {
          board.doDraw(kMovePass);
          break;
        }
        const x = board.parseX(token.charCodeAt(cursor));
        const y = board.parseY(token.charCodeAt(cursor + 1));
        board.doDraw(y * 9 + x);
        cursor += 2;
      }
    }());
  } else {
    board.offer(board.parseOffer(token));
    i++;
    token = qTokens[i];
    (function(){
      let cursor = 0;
      if (token[cursor] === '{') {
        cursor = board.parseDistribution(token, cursor).cursor;
      }
      const x = board.parseX(token.charCodeAt(cursor + 1));
      const y = board.parseY(token.charCodeAt(cursor + 2));
      const t = board.parseTile(token[cursor]);
      board.doPlace(y * 9 + x, t);
    }());
  }
}
let qPos = 0;
let wwyd = false; // I'm too lazy to come up with a better variable name, but true means reveal
let radioState = 'r_normal';
for (let i = 0; i < document.myRadios.radio.length; i++) {
  document.myRadios.radio[i].addEventListener('change', function() {
    if (radioState !== this.value) {
      radioState = this.value;
      showBoard();
    }
  });
}
showBoard();

</script></body></html>
